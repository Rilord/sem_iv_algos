#include "hermite.hpp"

#include <iostream>
#include <fstream>
#include <algorithm>
#include <iterator>
#include <sstream>
#include <stdbool.h>
#include <math.h>


void interpolation::loadFile(const std::string name) {

    std::ifstream f;

    f.open(name, std::ios::in);

    int i = 0;

    double x;

    std::string line;
    std::string temp;

    table.records.clear();


    while (getline(f, line)) {

        std::istringstream ss(line);

        table.records.emplace_back(std::istream_iterator<double>{ss}, 
                std::istream_iterator<double>{});

    }

    f.close();

    std::sort(table.records[0].begin(),
            table.records[0].end(),
            [] (double a, double b) {
                return a < b;
            }
            );

    tableSplit();
    getBase(this->arg);
}

void interpolation::printTable() {
    std::cout << "Y / X ";

    for (int i = 0; i < table.records[0].size(); i++)
        std::cout << table.records[0][i] << " ";
}

void interpolation::getBase(dot arg) {

    base_x.clear();
    base_y.clear();

    base_x = std::vector (x_args.begin(), x_args.end());

    std::sort(base_x.begin(), base_x.end(),
            [arg] (double a, double b) {
            return abs(a - arg.x) < abs(b - arg.x);
            }
    );


    std::sort(base_x.begin(), base_x.end(),
            [] (double a, double b) {
            return a < b;
            }
    );

    base_x = std::vector (x_args.begin(), x_args.begin() + nx + 1);


    base_y = std::vector (y_args.begin(), y_args.begin() + ny + 1);

    std::sort(base_y.begin(), base_y.end(),
            [arg] (double a, double b) {
            return abs(a - arg.y) < abs(b - arg.y);
            }
    );

    std::sort(base_y.begin(), base_y.end(),
            [] (double a, double b) {
            return a < b;
            }
    );

    for (auto &i: base_x) {
        std::cout << i << "\n";
    }

}

void interpolation::tableSplit() {

    x_args.clear();
    y_args.clear();
    matrix.clear();

    matrix.resize(10);

    for (auto i = 0; i < 10; i++) {
        matrix[i].resize(10);
    }

    x_args = table.records[0];

    for (int i = 1; i < table.records.size(); i++) {
        y_args.push_back(table.records[i][0]);
    }

    for (int i = 1; i < table.records.size(); i++) {
        for (int j = 1; j < table.records[i].size(); j++) {
            matrix[i - 1][j - 1] = table.records[i][j];
        }
    }

    for (auto i = 0; i < matrix.size(); i++) {
        for (auto j = 0; j < matrix[i].size(); j++) {
            std::cout << matrix[i][j] << " ";
        }
        std::cout << "\n";
    }
}

interpolation::interpolation(unsigned nx, unsigned ny, dot arg) {
    this->nx = nx;
    this->ny = ny;
    this->arg = arg;
}

double interpolation::getPolynomial() {
    std::vector<double> coefs;

    for (auto i = 0; i < ny; i++) {
        coefs.push_back(newtonPolynom(nx, matrix[i], base_x, arg.x).build());
    }

    answer = newtonPolynom(ny, coefs, base_y, arg.y).build();

    return answer;
}

void interpolation::setPolynomSize(unsigned int nx, unsigned int ny) {
    this->nx = nx;
    this->ny = ny;
}

void interpolation::setArg(dot arg) {
    this->arg = arg;
}

newtonPolynom::newtonPolynom(unsigned int n, std::vector<double> values, 
        std::vector<double> args, double x) {
    this->values = values;
    this->args = args;
    this->n = n;
    this->x = x;
}

double newtonPolynom::build() {

    std::vector<double> next;

    double y0 = values[0], val = 0;

    diffs.clear();

    for (auto i = 1; i < this->values.size(); i++) {
        for (auto t = 0; t < n - 1; t++) {
            next.push_back(
                    (values[t + 1] - values[t]) 
                    / 
                    (args[t + 1] - args[t]));
        }
        values = next; diffs.push_back(values[0]);
    }

    for (auto i = 0; i < n + 1; i++) {
        val = diffs[i];

        for (auto j = 0; j < i; j++) {
            val *= (this->x - args[j]);
        }
        y0 += val;
    }

    return y0;
}
